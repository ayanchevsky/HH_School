# Задача 2. Активные вакансии
# Условие задачи
#
# Ограничение времени, с	2
# Ограничение памяти, МБ	96
# Общее число попыток отправки	15
#
# Петя решил узнать, когда программисту выгоднее всего искать работу на hh.ru. Конечно, когда больше всего открыто
# вакансий.
#
# Он выгрузил в текстовый файл время открытия и закрытия всех подходящих вакансий за 2019 год.
#
# Теперь нужно определить период времени, когда открытых вакансий было больше всего.
#
# Считаем, что:
#
# - начальное и конечное время всегда присутствуют;
# - начальное время всегда меньше или равно конечному;
# - начальное и конечное время включены в интервал.
#
# Входные данные Входная информация поступает из стандартного ввода, в первой строке приходит 1 число - количество
# вакансий. Каждая из следующих строк содержит информацию о вакансии в виде двух чисел – начальное и конечное время,
# они разделены пробелом. Время задается в секундах (https://ru.wikipedia.org/wiki/Unix-время). Некорректные данные
# на вход не поступают, дополнительные проверки не требуются.
#
#
# Выходные данные В качестве ответа в стандартный вывод через пробел нужно вывести два числа: количество найденных
# интервалов и сумму длительности интервалов в секундах (начальная и конечная секунды должны быть включены в интервал).
# Пример 1
# Входные данные:
#
# 1
# 1595862781 1595862785
# Выходные данные: 1 5
#
#
# Пример 2
# Входные данные:
#
# 2
# 1595862781 1595862783
# 1595862782 1595862784
# Выходные данные: 1 2
#
#
# Пример 3
# Входные данные:
#
# 2
# 1595862781 1595862782
# 1595862783 1595862784
# Выходные данные: 2 4


intervals = int(input())
points = []
while intervals > 0:
    timers = input()
    time_list = timers.split()
    i_start = int(time_list[0])
    i_end = int(time_list[1])
    points.append([i_start, 0])
    points.append([i_end, 1])
    intervals -= 1

points.sort()
max_v = 0
max_start = 0
max_v_time = 0
max_v_num = 0
count = 0
for p in points:
    if p[1] == 0:
        count += 1
        if count > max_v:
            max_v = count
            max_v_num = 1
            max_start = p[0]
            max_v_time = 0
        elif count == max_v:
            max_v_num += 1
            max_start = p[0]
    else:
        if count == max_v:
            max_v_time += p[0] - max_start + 1
        count -= 1

print(max_v_num, max_v_time)

